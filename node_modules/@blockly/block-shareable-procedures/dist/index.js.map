{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-shareable-procedures/webpack/universalModuleDefinition","webpack://@blockly/block-shareable-procedures/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-shareable-procedures/webpack/bootstrap","webpack://@blockly/block-shareable-procedures/webpack/runtime/define property getters","webpack://@blockly/block-shareable-procedures/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-shareable-procedures/webpack/runtime/make namespace object","webpack://@blockly/block-shareable-procedures/./src/events_procedure_base.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_base.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_rename.ts","webpack://@blockly/block-shareable-procedures/./src/update_procedures.ts","webpack://@blockly/block-shareable-procedures/./src/observable_parameter_model.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_change_return.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_create.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_delete.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_enable.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_create.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_parameter_delete.ts","webpack://@blockly/block-shareable-procedures/./src/events_procedure_rename.ts","webpack://@blockly/block-shareable-procedures/./src/observable_procedure_model.ts","webpack://@blockly/block-shareable-procedures/./src/blocks.ts","webpack://@blockly/block-shareable-procedures/./src/i_procedure_block.ts","webpack://@blockly/block-shareable-procedures/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The base event for an event associated with a procedure.\n */\nexport abstract class ProcedureBase extends Blockly.Events.Abstract {\n  static readonly TYPE: string = 'procedure_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureBase.TYPE;\n\n  isBlank = false;\n\n  /**\n   * Constructs the base procedure event.\n   *\n   * @param workspace The workspace the procedure model exists in.\n   * @param procedure The procedure model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    readonly procedure: Blockly.procedures.IProcedureModel,\n  ) {\n    super();\n    this.workspaceId = workspace.id;\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureBaseJson {\n    const json = super.toJson() as ProcedureBaseJson;\n    json['procedureId'] = this.procedure.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureBaseJson extends Blockly.Events.AbstractEventJson {\n  procedureId: string;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * The base event for an event associated with a procedure parameter.\n */\nexport abstract class ProcedureParameterBase extends ProcedureBase {\n  static readonly TYPE: string = 'procedure_parameter_base';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterBase.TYPE;\n\n  /**\n   * Constructs the procedure parameter base event.\n   *\n   * @param workspace The workspace the parameter model exists in.\n   * @param procedure The procedure model the parameter model belongs to.\n   * @param parameter The parameter model associated with this event.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly parameter: Blockly.procedures.IParameterModel,\n  ) {\n    super(workspace, procedure);\n    this.recordUndo = false;\n  }\n\n  /**\n   * Finds the parameter with the given ID in the procedure model with the given\n   * ID, if both things exist.\n   *\n   * @param workspace The workspace to search for the parameter.\n   * @param procedureId The ID of the procedure model to search for\n   *     the parameter.\n   * @param paramId The ID of the parameter to search for.\n   * @returns The parameter model that was found.\n   * @internal\n   */\n  static findMatchingParameter(\n    workspace: Blockly.Workspace,\n    procedureId: string,\n    paramId: string,\n  ): ProcedureParameterPair {\n    const procedure = workspace.getProcedureMap().get(procedureId);\n    if (!procedure) return {procedure: undefined, parameter: undefined};\n    const parameter = procedure\n      .getParameters()\n      .find((p) => p.getId() === paramId);\n    if (!parameter) return {procedure, parameter: undefined};\n    return {procedure, parameter};\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterBaseJson {\n    const json = super.toJson() as ProcedureParameterBaseJson;\n    json['parameterId'] = this.parameter.getId();\n    return json;\n  }\n}\n\nexport interface ProcedureParameterPair {\n  procedure?: Blockly.procedures.IProcedureModel;\n  parameter?: Blockly.procedures.IParameterModel;\n}\n\nexport interface ProcedureParameterBaseJson extends ProcedureBaseJson {\n  parameterId: string;\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a procedure parameter was renamed.\n */\nexport class ProcedureParameterRename extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterRename.TYPE;\n\n  /** The new name of the procedure parameter. */\n  private readonly newName: string;\n\n  /** The new ID the backing variable for the parameter. */\n  private readonly newVarId: string;\n\n  /**\n   * Constructs the procedure parameter rename event.\n   *\n   * @param workspace The workpace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model this event is associated with.\n   * @param oldName The old name of the procedure parameter.\n   * @param newName The (optional) new name of the procedure parameter. If not\n   *     provided, the parameter model will be inspected to see what its current\n   *     name is.\n   * @param newVarId The (optional) new id of the procedure parameter's backing\n   *     variable. If not provided, the parameter model will be inspected to\n   *     see what its current name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly oldName: string,\n    newName?: string,\n    newVarId?: string,\n  ) {\n    super(workspace, procedure, parameter);\n\n    this.newName = newName ?? parameter.getName();\n    this.newVarId = newVarId ?? parameter.getVariableModel().getId();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const {parameter} = ProcedureParameterBase.findMatchingParameter(\n      this.getEventWorkspace_(),\n      this.procedure.getId(),\n      this.parameter.getId(),\n    );\n    if (forward) {\n      if (parameter.getName() !== this.oldName) return;\n      (parameter as ObservableParameterModel).setName(\n        this.newName,\n        this.newVarId,\n      );\n    } else {\n      if (parameter.getName() !== this.newName) return;\n      parameter.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterRenameJson {\n    const json = super.toJson() as ProcedureParameterRenameJson;\n    json['newName'] = this.newName;\n    json['newVarId'] = this.newVarId;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterRename {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterRename(\n      workspace,\n      procedure,\n      parameter as ObservableParameterModel,\n      json['oldName'],\n      json['newName'],\n      json['newVarId'],\n    );\n  }\n}\n\nexport interface ProcedureParameterRenameJson\n  extends ProcedureParameterBaseJson {\n  oldName: string;\n  newName: string;\n  newVarId: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterRename.TYPE,\n  ProcedureParameterRename,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Calls the `doProcedureUpdate` method on all blocks which implement it.\n *\n * @param workspace The workspace within which to trigger block updates.\n * @internal\n */\nexport function triggerProceduresUpdate(workspace: Blockly.Workspace) {\n  if (workspace.isClearing) return;\n  for (const block of workspace.getAllBlocks(false)) {\n    if (Blockly.procedures.isProcedureBlock(block)) {\n      block.doProcedureUpdate();\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureParameterRename} from './events_procedure_parameter_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure parameter. */\nexport class ObservableParameterModel\n  implements Blockly.procedures.IParameterModel\n{\n  private id: string;\n  private variable: Blockly.VariableModel;\n  private shouldFireEvents = false;\n  private procedureModel: Blockly.procedures.IProcedureModel | null = null;\n\n  /**\n   * Constructor for the procedure parameter.\n   *\n   * @param workspace The workspace this parameter model exists in.\n   * @param name The name of this parameter.\n   * @param id The optional unique language-neutral ID of the parameter.\n   * @param varId The optional ID of the variable this parameter should be\n   *     associated with.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n    varId?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.variable = this.createBackingVariable(name, varId);\n  }\n\n  /**\n   * Sets the name of this parameter to the given name.\n   *\n   * @param name The string to set the name to.\n   * @param id The optional ID the backing variable should have.\n   * @returns This parameter model.\n   */\n  setName(name: string, id?: string): this {\n    if (name === this.variable.name) return this;\n    const oldName = this.variable.name;\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', id);\n    triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterRename(\n          this.workspace,\n          this.procedureModel,\n          this,\n          oldName,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Creates a backing variable in a way that is subclassable.\n   *\n   * @param name The string to set set the variable to.\n   * @param varId The optional ID the backing variable should have.\n   * @returns The created variable model.\n   */\n  protected createBackingVariable(\n    name: string,\n    varId?: string,\n  ): Blockly.VariableModel {\n    this.variable =\n      this.workspace.getVariable(name) ??\n      this.workspace.createVariable(name, '', varId);\n    return this.variable;\n  }\n\n  /**\n   * Unimplemented. The built-in ParameterModel does not support typing.\n   * If you want your procedure blocks to have typed parameters, you need to\n   * implement your own ParameterModel.\n   *\n   * @param types The types to set this parameter to.\n   * @throws Throws for the ObservableParameterModel specifically because this\n   *     method is unimplemented.\n   */\n  setTypes(types: string[]): this {\n    throw new Error(\n      'The built-in ParameterModel does not support typing. You need to ' +\n        'implement your own custom ParameterModel.',\n    );\n  }\n\n  /**\n   * @returns the name of this parameter.\n   */\n  getName(): string {\n    return this.variable.name;\n  }\n\n  /**\n   * @returns the types of this parameter.\n   */\n  getTypes(): string[] {\n    return [];\n  }\n\n  /**\n   * Returns the unique language-neutral ID for the parameter. This represents\n   * the identity of the variable model which does not change over time.\n   *\n   * @returns The unique language-neutral ID for the parameter.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns the variable model associated with the parameter model.\n   */\n  getVariableModel(): Blockly.VariableModel {\n    return this.variable;\n  }\n\n  /**\n   * Tells the parameter model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n  }\n\n  /**\n   * Tells the parameter model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    this.shouldFireEvents = false;\n  }\n\n  /**\n   * Sets the procedure model this parameter is a part of.\n   *\n   * @param model The procedure model this parameter is a part of.\n   * @returns This parameter model.\n   */\n  setProcedureModel(model: Blockly.procedures.IProcedureModel): this {\n    this.procedureModel = model;\n    return this;\n  }\n\n  /**\n   * Serializes the state of this parameter to JSON.\n   *\n   * @returns JSON serializable state of the parameter.\n   */\n  saveState(): Blockly.serialization.procedures.ParameterState {\n    const state: Blockly.serialization.procedures.ParameterState = {\n      id: this.getId(),\n      name: this.getName(),\n    };\n    if (!this.getTypes().length) return state;\n    state.types = this.getTypes();\n    return state;\n  }\n\n  /**\n   * Returns a new parameter model with the given state.\n   *\n   * @param state The state of the parameter to load.\n   * @param workspace The workspace to load the parameter into.\n   * @returns The loaded parameter model.\n   */\n  static loadState(\n    state: Blockly.serialization.procedures.ParameterState,\n    workspace: Blockly.Workspace,\n  ): ObservableParameterModel {\n    const model = new ObservableParameterModel(workspace, state.name, state.id);\n    if (state.types) model.setTypes(state.types);\n    return model;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure's return type/status has changed.\n */\nexport class ProcedureChangeReturn extends ProcedureBase {\n  static readonly TYPE = 'procedure_change';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureChangeReturn.TYPE;\n\n  /** The new type(s) the procedure's return has been set to. */\n  private newTypes: string[] | null;\n\n  /**\n   * Constructs the procedure change event.\n   *\n   * @param workpace The workspace this change event is associated with.\n   * @param procedure The model this change event is associated with.\n   * @param oldTypes The type(s) the procedure's return was set to before it\n   *     changed.\n   */\n  constructor(\n    workpace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldTypes: string[] | null,\n  ) {\n    super(workpace, procedure);\n\n    this.newTypes = procedure.getReturnTypes();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setReturnTypes(this.newTypes);\n    } else {\n      procedureModel.setReturnTypes(this.oldTypes);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureChangeReturnJson {\n    const json = super.toJson() as ProcedureChangeReturnJson;\n    json['oldTypes'] = this.oldTypes;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure change event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure change return event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureChangeReturnJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureChangeReturn {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure change return event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureChangeReturn(workspace, model, json['oldTypes']);\n  }\n}\n\nexport interface ProcedureChangeReturnJson extends ProcedureBaseJson {\n  oldTypes: string[] | null;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureChangeReturn.TYPE,\n  ProcedureChangeReturn,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\n/**\n * Notifies listeners that a procedure data model has been created.\n */\nexport class ProcedureCreate extends ProcedureBase {\n  static readonly TYPE = 'procedure_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureCreate.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    } else {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureCreateJson {\n    const json = super.toJson() as ProcedureCreateJson;\n    json['procedure'] = Blockly.serialization.procedures.saveProcedure(\n      this.procedure,\n    );\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureCreate {\n    return new ProcedureCreate(\n      workspace,\n      Blockly.serialization.procedures.loadProcedure(\n        ObservableProcedureModel,\n        ObservableParameterModel,\n        json['procedure'],\n        workspace,\n      ),\n    );\n  }\n}\n\nexport interface ProcedureCreateJson extends ProcedureBaseJson {\n  procedure: Blockly.serialization.procedures.State;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureCreate.TYPE,\n  ProcedureCreate,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that a procedure data model has been deleted.\n */\nexport class ProcedureDelete extends ProcedureBase {\n  static readonly TYPE = 'procedure_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureDelete.TYPE;\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    if (forward) {\n      if (!procedureMap.get(this.procedure.getId())) return;\n      procedureMap.delete(this.procedure.getId());\n    } else {\n      if (procedureMap.get(this.procedure.getId())) return;\n      procedureMap.add(this.procedure);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureDeleteJson {\n    return super.toJson() as ProcedureDeleteJson;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureDelete {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure delete event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureDelete(workspace, model);\n  }\n}\n\nexport type ProcedureDeleteJson = ProcedureBaseJson;\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureDelete.TYPE,\n  ProcedureDelete,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/**\n * Notifies listeners that the procedure data model has been enabled or\n * disabled.\n */\nexport class ProcedureEnable extends ProcedureBase {\n  static readonly TYPE = 'procedure_enable';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureEnable.TYPE;\n\n  private oldState: boolean;\n  private newState: boolean;\n\n  /**\n   * Constructs the procedure enable event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param newState The (optional) new enabled state of the procedure model.\n   *     If not provided, the procedure model will be inspected to determine\n   *     its current state.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    newState?: boolean,\n  ) {\n    super(workspace, procedure);\n\n    if (newState === undefined) {\n      this.oldState = !procedure.getEnabled();\n      this.newState = procedure.getEnabled();\n    } else {\n      this.oldState = !newState;\n      this.newState = newState;\n    }\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the enabled state of a procedure that does not ' +\n          'exist in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.setEnabled(this.newState);\n    } else {\n      procedureModel.setEnabled(this.oldState);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureEnableJson {\n    const json = super.toJson() as ProcedureEnableJson;\n    json['newState'] = this.newState;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure enable event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure enable event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureEnableJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureEnable {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure enable event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureEnable(workspace, model, json['newState']);\n  }\n}\n\nexport interface ProcedureEnableJson extends ProcedureBaseJson {\n  newState: boolean;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureEnable.TYPE,\n  ProcedureEnable,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nimport {ObservableParameterModel} from './observable_parameter_model';\n\n/**\n * Notifies listeners that a parameter has been added to a procedure model.\n */\nexport class ProcedureParameterCreate extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_create';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterCreate.TYPE;\n\n  parameter: ObservableParameterModel;\n\n  /**\n   * Constructs the procedure parameter create event.js.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just added to the procedure.\n   * @param index The index the parameter was inserted at.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: ObservableParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.insertParameter(this.parameter, this.index);\n    } else {\n      procedureModel.deleteParameter(this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterCreateJson {\n    const json = super.toJson() as ProcedureParameterCreateJson;\n    json['name'] = this.parameter.getName();\n    json['id'] = this.parameter.getId();\n    json['varId'] = this.parameter.getVariableModel().getId();\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter create event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter create event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterCreateJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterCreate {\n    const procedure = workspace.getProcedureMap().get(json['procedureId']);\n    if (!procedure) {\n      throw new Error(\n        'Cannot deserialize parameter create event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureParameterCreate(\n      workspace,\n      procedure,\n      new ObservableParameterModel(\n        workspace,\n        json['name'],\n        json['id'],\n        json['varId'],\n      ),\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterCreateJson\n  extends ProcedureParameterBaseJson {\n  parameter: Blockly.serialization.procedures.ParameterState;\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterCreate.TYPE,\n  ProcedureParameterCreate,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\n\n/**\n * Notifies listeners that a parameter has been removed from a procedure.\n */\nexport class ProcedureParameterDelete extends ProcedureParameterBase {\n  static readonly TYPE = 'procedure_parameter_delete';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureParameterDelete.TYPE;\n\n  /**\n   * Constructs the procedure parameter delete event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The procedure model this event is associated with.\n   * @param parameter The parameter model that was just removed from the\n   *     procedure.\n   * @param index The index the parameter was at before it was removed.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    parameter: Blockly.procedures.IParameterModel,\n    readonly index: number,\n  ) {\n    super(workspace, procedure, parameter);\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const workspace = this.getEventWorkspace_();\n    const procedureMap = workspace.getProcedureMap();\n    const procedureModel = procedureMap.get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot add a parameter to a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      procedureModel.deleteParameter(this.index);\n    } else {\n      procedureModel.insertParameter(this.parameter, this.index);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureParameterDeleteJson {\n    const json = super.toJson() as ProcedureParameterDeleteJson;\n    json['index'] = this.index;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure parameter delete event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure parameter delete event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureParameterDeleteJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureParameterDelete {\n    const {procedure, parameter} = ProcedureParameterBase.findMatchingParameter(\n      workspace,\n      json['procedureId'],\n      json['parameterId'],\n    );\n    if (!parameter) {\n      throw new Error('Cannot delete a non existant parameter');\n    }\n    return new ProcedureParameterDelete(\n      workspace,\n      procedure,\n      parameter,\n      json['index'],\n    );\n  }\n}\n\nexport interface ProcedureParameterDeleteJson\n  extends ProcedureParameterBaseJson {\n  index: number;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureParameterDelete.TYPE,\n  ProcedureParameterDelete,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\n\n/** Notifies listeners that a procedure model has been renamed. */\nexport class ProcedureRename extends ProcedureBase {\n  static readonly TYPE = 'procedure_rename';\n\n  /** A string used to check the type of the event. */\n  type = ProcedureRename.TYPE;\n\n  private newName: string;\n\n  /**\n   * Constructs the procedure rename event.\n   *\n   * @param workspace The workspace this event is associated with.\n   * @param procedure The model this event is associated with.\n   * @param oldName The old name of the procedure model.\n   * @param newName The (optional) new name of the procedure. If not provided,\n   *     the procedure model will be inspected to see what its current\n   *     name is.\n   */\n  constructor(\n    workspace: Blockly.Workspace,\n    procedure: Blockly.procedures.IProcedureModel,\n    readonly oldName: string,\n    newName?: string,\n  ) {\n    super(workspace, procedure);\n\n    this.newName = newName ?? procedure.getName();\n  }\n\n  /**\n   * Replays the event in the workspace.\n   *\n   * @param forward if true, play the event forward (redo), otherwise play it\n   *     backward (undo).\n   */\n  run(forward: boolean) {\n    const procedureModel = this.getEventWorkspace_()\n      .getProcedureMap()\n      .get(this.procedure.getId());\n    if (!procedureModel) {\n      throw new Error(\n        'Cannot change the type of a procedure that does not exist ' +\n          'in the procedure map',\n      );\n    }\n    if (forward) {\n      if (procedureModel.getName() !== this.oldName) return;\n      procedureModel.setName(this.newName);\n    } else {\n      if (procedureModel.getName() !== this.newName) return;\n      procedureModel.setName(this.oldName);\n    }\n  }\n\n  /**\n   * Encode the event as JSON.\n   *\n   * @returns JSON representation.\n   */\n  toJson(): ProcedureRenameJson {\n    const json = super.toJson() as ProcedureRenameJson;\n    json['newName'] = this.newName;\n    json['oldName'] = this.oldName;\n    return json;\n  }\n\n  /**\n   * Deserializes the JSON event.\n   *\n   * @param json The JSON representation of a procedure rename event.\n   * @param workspace The workspace to deserialize the event into.\n   * @returns The new procedure rename event.\n   * @internal\n   */\n  static fromJson(\n    json: ProcedureRenameJson,\n    workspace: Blockly.Workspace,\n  ): ProcedureRename {\n    const model = workspace.getProcedureMap().get(json['procedureId']);\n    if (!model) {\n      throw new Error(\n        'Cannot deserialize procedure rename event because the ' +\n          'target procedure does not exist',\n      );\n    }\n    return new ProcedureRename(\n      workspace,\n      model,\n      json['oldName'],\n      json['newName'],\n    );\n  }\n}\n\nexport interface ProcedureRenameJson extends ProcedureBaseJson {\n  oldName: string;\n  newName: string;\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.EVENT,\n  ProcedureRename.TYPE,\n  ProcedureRename,\n);\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ProcedureChangeReturn} from './events_procedure_change_return';\nimport {ProcedureCreate} from './events_procedure_create';\nimport {ProcedureDelete} from './events_procedure_delete';\nimport {ProcedureEnable} from './events_procedure_enable';\nimport {ProcedureParameterCreate} from './events_procedure_parameter_create';\nimport {ProcedureParameterDelete} from './events_procedure_parameter_delete';\nimport {ProcedureRename} from './events_procedure_rename';\nimport {triggerProceduresUpdate} from './update_procedures';\n\n/** Represents a procedure signature. */\nexport class ObservableProcedureModel\n  implements Blockly.procedures.IProcedureModel\n{\n  private id: string;\n  private name: string;\n  private parameters: ObservableParameterModel[] = [];\n  private returnTypes: string[] | null = null;\n  private enabled = true;\n  private shouldFireEvents = false;\n  private shouldTriggerUpdates = true;\n\n  /**\n   * Constructor for the procedure model.\n   *\n   * @param workspace The workspace the procedure model is associated with.\n   * @param name The name of the new procedure.\n   * @param id The (optional) unique language-neutral ID for the procedure.\n   */\n  constructor(\n    private readonly workspace: Blockly.Workspace,\n    name: string,\n    id?: string,\n  ) {\n    this.id = id ?? Blockly.utils.idGenerator.genUid();\n    this.name = name;\n  }\n\n  /**\n   * Sets the human-readable name of the procedure.\n   *\n   * @param name The human-readable name of the procedure.\n   * @returns This procedure model.\n   */\n  setName(name: string): this {\n    if (name === this.name) return this;\n    const oldName = this.name;\n    this.name = name;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureRename(this.workspace, this, oldName));\n    }\n    return this;\n  }\n\n  /**\n   * Inserts a parameter into the list of parameters.\n   * To move a parameter, first delete it, and then re-insert.\n   *\n   * @param parameterModel The parameter model to insert.\n   * @param index The index to insert it at.\n   * @returns This procedure model.\n   */\n  insertParameter(\n    parameterModel: ObservableParameterModel,\n    index: number,\n  ): this {\n    if (\n      this.parameters[index] &&\n      this.parameters[index].getId() === parameterModel.getId()\n    ) {\n      return this;\n    }\n\n    this.parameters.splice(index, 0, parameterModel);\n    parameterModel.setProcedureModel(this);\n    if (Blockly.isObservable(parameterModel)) {\n      if (this.shouldFireEvents) {\n        parameterModel.startPublishing();\n      } else {\n        parameterModel.stopPublishing();\n      }\n    }\n\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterCreate(\n          this.workspace,\n          this,\n          parameterModel,\n          index,\n        ),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Removes the parameter at the given index from the parameter list.\n   *\n   * @param index The index of the parameter to remove.\n   * @returns This procedure model.\n   */\n  deleteParameter(index: number): this {\n    if (!this.parameters[index]) return this;\n    const oldParam = this.parameters[index];\n\n    this.parameters.splice(index, 1);\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (Blockly.isObservable(oldParam)) {\n      oldParam.stopPublishing();\n    }\n\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureParameterDelete(this.workspace, this, oldParam, index),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether the procedure has a return value (empty array) or no return\n   * value (null).\n   * This procedure model does not support procedures that have actual\n   * return types (i.e. non-empty arrays, e.g. ['number']).\n   *\n   * @param types Used to set whether this procedure has a return value\n   *     (empty array) or no return value (null).\n   * @returns This procedure model.\n   */\n  setReturnTypes(types: string[] | null): this {\n    if (types && types.length) {\n      throw new Error(\n        'The built-in ProcedureModel does not support typing. You need to ' +\n          'implement your own custom ProcedureModel.',\n      );\n    }\n    // Either they're both an empty array, or both null. Noop either way.\n    if (!!types === !!this.returnTypes) return this;\n    const oldReturnTypes = this.returnTypes;\n    this.returnTypes = types;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(\n        new ProcedureChangeReturn(this.workspace, this, oldReturnTypes),\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Sets whether this procedure is enabled/disabled. If a procedure is disabled\n   * all procedure caller blocks should be disabled as well.\n   *\n   * @param enabled Whether this procedure is enabled/disabled.\n   * @returns This procedure model.\n   */\n  setEnabled(enabled: boolean): this {\n    if (enabled === this.enabled) return this;\n    this.enabled = enabled;\n    if (this.shouldTriggerUpdates) triggerProceduresUpdate(this.workspace);\n    if (this.shouldFireEvents) {\n      Blockly.Events.fire(new ProcedureEnable(this.workspace, this));\n    }\n    return this;\n  }\n\n  /**\n   * Disables triggering updates to procedure blocks until the endBulkUpdate\n   * is called.\n   *\n   * @internal\n   */\n  startBulkUpdate() {\n    this.shouldTriggerUpdates = false;\n  }\n\n  /**\n   * Triggers an update to procedure blocks. Should be used with\n   * startBulkUpdate.\n   *\n   * @internal\n   */\n  endBulkUpdate() {\n    this.shouldTriggerUpdates = true;\n    triggerProceduresUpdate(this.workspace);\n  }\n\n  /**\n   * @returns The unique language-neutral ID for the procedure.\n   */\n  getId(): string {\n    return this.id;\n  }\n\n  /**\n   * @returns The human-readable name of the procedure\n   */\n  getName(): string {\n    return this.name;\n  }\n\n  /**\n   * @param index The index of the parameter to return.\n   * @returns the parameter at the given index in the parameter list.\n   */\n  getParameter(index: number): Blockly.procedures.IParameterModel {\n    return this.parameters[index];\n  }\n\n  /**\n   * @returns an array of all of the parameters in the parameter list.\n   */\n  getParameters(): Blockly.procedures.IParameterModel[] {\n    return [...this.parameters];\n  }\n\n  /**\n   * Returns the return type of the procedure.\n   * Null represents a procedure that does not return a value.\n   *\n   * @returns the return type of the procedure.\n   */\n  getReturnTypes(): string[] | null {\n    return this.returnTypes;\n  }\n\n  /**\n   * Returns whether the procedure is enabled/disabled. If a procedure is\n   * disabled, all procedure caller blocks should be disabled as well.\n   *\n   * @returns Returns whether the procedure is enabled/disabled.\n   */\n  getEnabled(): boolean {\n    return this.enabled;\n  }\n\n  /**\n   * Tells the procedure model it should fire events.\n   *\n   * @internal\n   */\n  startPublishing() {\n    this.shouldFireEvents = true;\n    Blockly.Events.fire(new ProcedureCreate(this.workspace, this));\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.startPublishing();\n    }\n  }\n\n  /**\n   * Tells the procedure model it should not fire events.\n   *\n   * @internal\n   */\n  stopPublishing() {\n    triggerProceduresUpdate(this.workspace);\n    Blockly.Events.fire(new ProcedureDelete(this.workspace, this));\n    this.shouldFireEvents = false;\n    for (const param of this.parameters) {\n      if (Blockly.isObservable(param)) param.stopPublishing();\n    }\n  }\n\n  /**\n   * Serializes the state of the procedure to JSON.\n   *\n   * @returns JSON serializable state of the procedure.\n   */\n  saveState(): Blockly.serialization.procedures.State {\n    // Parameter state is serialized by core.\n    return {\n      id: this.getId(),\n      name: this.getName(),\n      returnTypes: this.getReturnTypes(),\n    };\n  }\n\n  /**\n   * Returns a new procedure model with the given state.\n   *\n   * @param state The state of the procedure to load.\n   * @param workspace The workspace to load the procedure into.\n   * @returns The loaded procedure model.\n   */\n  static loadState(\n    state: Blockly.serialization.procedures.State,\n    workspace: Blockly.Workspace,\n  ): ObservableProcedureModel {\n    return new ObservableProcedureModel(\n      workspace,\n      state.name,\n      state.id,\n    ).setReturnTypes(state.returnTypes);\n  }\n}\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n'use strict';\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableProcedureModel} from './observable_procedure_model';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {IProcedureBlock} from './i_procedure_block';\nimport {ProcedureCreate} from './events_procedure_create';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A dictionary of the block definitions provided by this module.\n *\n * @type {!Object<string, Object>}\n */\nexport const blocks = Blockly.common.createBlockDefinitionsFromJsonArray([\n  {\n    type: 'procedures_defnoreturn',\n    message0: '%{BKY_PROCEDURES_DEFNORETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFNORETURN_DO} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFNORETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFNORETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defnoreturn_get_caller_block_mixin',\n      'procedure_defnoreturn_set_comment_helper',\n      'procedure_def_set_no_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callnoreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    nextStatement: null,\n    previousStatement: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLNORETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callernoreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n  {\n    type: 'procedures_defreturn',\n    message0: '%{BKY_PROCEDURES_DEFRETURN_TITLE} %1 %2 %3',\n    message1: '%{BKY_PROCEDURES_DEFRETURN_DO} %1',\n    message2: '%{BKY_PROCEDURES_DEFRETURN_RETURN} %1',\n    args0: [\n      {\n        type: 'field_input',\n        name: 'NAME',\n        text: '',\n        spellcheck: false,\n      },\n      {\n        type: 'field_label',\n        name: 'PARAMS',\n        text: '',\n      },\n      {\n        type: 'input_dummy',\n        name: 'TOP',\n      },\n    ],\n    args1: [\n      {\n        type: 'input_statement',\n        name: 'STACK',\n      },\n    ],\n    args2: [\n      {\n        type: 'input_value',\n        align: 'right',\n        name: 'RETURN',\n      },\n    ],\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_DEFRETURN_HELPURL}',\n    tooltip: '%{BKY_PROCEDURES_DEFRETURN_TOOLTIP}',\n    extensions: [\n      'procedure_def_get_def_mixin',\n      'procedure_def_var_mixin',\n      'procedure_def_update_shape_mixin',\n      'procedure_def_context_menu_mixin',\n      'procedure_def_onchange_mixin',\n      'procedure_def_validator_helper',\n      'procedure_defreturn_get_caller_block_mixin',\n      'procedure_defreturn_set_comment_helper',\n      'procedure_def_set_return_helper',\n    ],\n    mutator: 'procedure_def_mutator',\n  },\n  {\n    type: 'procedures_callreturn',\n    message0: '%1 %2',\n    args0: [\n      {type: 'field_label', name: 'NAME', text: '%{BKY_UNNAMED_KEY}'},\n      {\n        type: 'input_dummy',\n        name: 'TOPROW',\n      },\n    ],\n    output: null,\n    style: 'procedure_blocks',\n    helpUrl: '%{BKY_PROCEDURES_CALLRETURN_HELPURL}',\n    extensions: [\n      'procedure_caller_get_def_mixin',\n      'procedure_caller_var_mixin',\n      'procedure_caller_update_shape_mixin',\n      'procedure_caller_context_menu_mixin',\n      'procedure_caller_onchange_mixin',\n      'procedure_callerreturn_get_def_block_mixin',\n    ],\n    mutator: 'procedure_caller_mutator',\n  },\n]);\n\nconst procedureDefGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    /**\n     * Returns the data model for this procedure block.\n     *\n     * @returns The data model for this procedure\n     *     block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns True because this is a procedure definition block.\n     */\n    isProcedureDef() {\n      return true;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n\n    /**\n     * Disposes of the data model for this procedure block when the block is\n     * disposed.\n     */\n    destroy: function () {\n      if (!this.isInsertionMarker()) {\n        this.workspace\n          .getProcedureMap()\n          .delete(this.getProcedureModel().getId());\n      }\n    },\n  };\n\n  mixin.model_ = new ObservableProcedureModel(\n    this.workspace,\n    Blockly.Procedures.findLegalName(this.getFieldValue('NAME'), this),\n  );\n\n  // Events cannot be fired from instantiation when deserializing or dragging\n  // from the flyout. So make this consistent and never fire from instantiation.\n  Blockly.Events.disable();\n  this.workspace.getProcedureMap().add(mixin.getProcedureModel());\n  Blockly.Events.enable();\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_def_get_def_mixin',\n  procedureDefGetDefMixin,\n);\n\nconst procedureDefVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming.\n     * If the ID matches one of this block's variables, rename it.\n     *\n     * @param oldId ID of variable to rename.\n     * @param newId ID of new variable.  May be the same as oldId, but\n     *     with an updated name.  Guaranteed to be the same type as the old\n     *     variable.\n     * @override\n     * @this {Blockly.Block}\n     */\n    renameVarById: function (oldId, newId) {\n      const oldVar = this.workspace.getVariableById(oldId);\n      const model = this.getProcedureModel();\n      const index = model\n        .getParameters()\n        .findIndex((p) => p.getVariableModel() === oldVar);\n      if (index === -1) return; // Not found.\n      const newVar = this.workspace.getVariableById(newId);\n      const oldParam = model.getParameter(index);\n      oldParam.setName(newVar.name);\n    },\n\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register('procedure_def_var_mixin', procedureDefVarMixin);\n\nconst procedureDefUpdateShapeMixin = {\n  /**\n   * Updates the block to reflect the state of the procedure model.\n   */\n  doProcedureUpdate: function () {\n    this.setFieldValue(this.getProcedureModel().getName(), 'NAME');\n    this.setEnabled(this.getProcedureModel().getEnabled());\n    this.updateParameters_();\n    this.updateMutator_();\n  },\n\n  /**\n   * Updates the parameters field to reflect the parameters in the procedure\n   * model.\n   */\n  updateParameters_: function () {\n    const params = this.getProcedureModel()\n      .getParameters()\n      .map((p) => p.getName());\n    const paramString = params.length\n      ? `${Blockly.Msg['PROCEDURES_BEFORE_PARAMS']} ${params.join(', ')}`\n      : '';\n\n    // The field is deterministic based on other events, no need to fire.\n    Blockly.Events.disable();\n    try {\n      this.setFieldValue(paramString, 'PARAMS');\n    } finally {\n      Blockly.Events.enable();\n    }\n  },\n\n  /**\n   * Updates the parameter blocks in the mutator (if it is open) to reflect\n   * the state of the procedure model.\n   */\n  updateMutator_: function () {\n    const mutator = this.getIcon(Blockly.icons.MutatorIcon.TYPE);\n    if (!mutator?.bubbleIsVisible()) return;\n\n    const mutatorWorkspace = this.mutator.getWorkspace();\n    for (const p of this.getProcedureModel().getParameters()) {\n      const block = mutatorWorkspace.getBlockById(p.getId());\n      if (!block) continue; // Should not happen.\n      if (block.getFieldValue('NAME') !== p.getName()) {\n        block.setFieldValue(p.getName(), 'NAME');\n      }\n    }\n  },\n\n  /**\n   * Add or remove the statement block from this function definition.\n   *\n   * @param hasStatements True if a statement block is needed.\n   * @this {Blockly.Block}\n   */\n  setStatements_: function (hasStatements) {\n    if (this.hasStatements_ === hasStatements) {\n      return;\n    }\n    if (hasStatements) {\n      this.appendStatementInput('STACK').appendField(\n        Blockly.Msg['PROCEDURES_DEFNORETURN_DO'],\n      );\n      if (this.getInput('RETURN')) {\n        this.moveInputBefore('STACK', 'RETURN');\n      }\n      // Restore the stack, if one was saved.\n      this.statementConnection_?.(this, 'STACK');\n      this.statementConnection_ = null;\n    } else {\n      // Save the stack, then disconnect it.\n      const stackConnection = this.getInput('STACK').connection;\n      this.statementConnection_ = stackConnection.targetConnection;\n      if (this.statementConnection_) {\n        const stackBlock = stackConnection.targetBlock();\n        stackBlock.unplug();\n        stackBlock.bumpNeighbours();\n      }\n      this.removeInput('STACK', true);\n    }\n    this.hasStatements_ = hasStatements;\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_update_shape_mixin',\n  procedureDefUpdateShapeMixin,\n);\n\nconst procedureDefValidatorHelper = function () {\n  const nameField = this.getField('NAME');\n  nameField.setValue(Blockly.Procedures.findLegalName('', this));\n  nameField.setValidator(Blockly.Procedures.rename);\n};\nBlockly.Extensions.register(\n  'procedure_def_validator_helper',\n  procedureDefValidatorHelper,\n);\n\nconst procedureDefMutator = {\n  hasStatements_: true,\n\n  /**\n   * Create XML to represent the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const params = this.getProcedureModel().getParameters();\n    for (let i = 0; i < params.length; i++) {\n      const parameter = Blockly.utils.xml.createElement('arg');\n      const varModel = params[i].getVariableModel();\n      parameter.setAttribute('name', varModel.name);\n      parameter.setAttribute('varid', varModel.getId());\n      container.appendChild(parameter);\n    }\n\n    // Save whether the statement input is visible.\n    if (!this.hasStatements_) {\n      container.setAttribute('statements', 'false');\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the argument inputs.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    for (let i = 0; i < xmlElement.childNodes.length; i++) {\n      const node = xmlElement.childNodes[i];\n      if (node.nodeName.toLowerCase() !== 'arg') continue;\n      const varId = node.getAttribute('varid');\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(\n          this.workspace,\n          node.getAttribute('name'),\n          undefined,\n          varId,\n        ),\n        i,\n      );\n    }\n    this.setStatements_(xmlElement.getAttribute('statements') !== 'false');\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @param doFullSerialization Tells the block if it should serialize\n   *     its entire state (including data stored in the backing procedure\n   *     model). Used for copy-paste.\n   * @returns The state of this block, eg the parameters and statements.\n   */\n  saveExtraState: function (doFullSerialization) {\n    const state = Object.create(null);\n    state['procedureId'] = this.getProcedureModel().getId();\n\n    if (doFullSerialization) {\n      state['fullSerialization'] = true;\n      const params = this.getProcedureModel().getParameters();\n      if (params.length) {\n        state['params'] = params.map((p) => {\n          return {\n            name: p.getName(),\n            id: p.getVariableModel().getId(),\n            // Ideally this would be id, and the other would be varId,\n            // but backwards compatibility :/\n            paramId: p.getId(),\n          };\n        });\n      }\n    }\n    if (!this.hasStatements_) {\n      state['hasStatements'] = false;\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, eg the parameters and\n   *     statements.\n   */\n  loadExtraState: function (state) {\n    const map = this.workspace.getProcedureMap();\n\n    const procedureId = state['procedureId'];\n    if (map.has(procedureId) && !state['fullSerialization']) {\n      if (map.has(this.model_.getId())) {\n        map.delete(this.model_.getId());\n      }\n      this.model_ = map.get(procedureId);\n    }\n\n    const model = this.getProcedureModel();\n    const newParams = state['params'] ?? [];\n    const newIds = new Set(newParams.map((p) => p.id));\n    const currParams = model.getParameters();\n    if (state['fullSerialization']) {\n      for (let i = currParams.length - 1; i >= 0; i--) {\n        if (!newIds.has(currParams[i].getId)) {\n          model.deleteParameter(i);\n        }\n      }\n    }\n    for (let i = 0; i < newParams.length; i++) {\n      const {name, id, paramId} = state['params'][i];\n      this.getProcedureModel().insertParameter(\n        new ObservableParameterModel(this.workspace, name, paramId, id),\n        i,\n      );\n    }\n\n    this.doProcedureUpdate();\n    this.setStatements_(state['hasStatements'] === false ? false : true);\n  },\n\n  /**\n   * Populate the mutator's dialog with this block's components.\n   *\n   * @param workspace Blockly.Mutator's workspace.\n   * @returns Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  decompose: function (workspace) {\n    const containerBlockDef = {\n      type: 'procedures_mutatorcontainer',\n      inputs: {\n        STACK: {},\n      },\n    };\n\n    let connDef = containerBlockDef['inputs']['STACK'];\n    for (const param of this.getProcedureModel().getParameters()) {\n      connDef['block'] = {\n        type: 'procedures_mutatorarg',\n        id: param.getId(),\n        fields: {\n          NAME: param.getName(),\n        },\n        next: {},\n      };\n      connDef = connDef['block']['next'];\n    }\n\n    const containerBlock = Blockly.serialization.blocks.append(\n      containerBlockDef as unknown as Blockly.serialization.blocks.State,\n      workspace,\n      {recordUndo: false},\n    );\n\n    if (this.type === 'procedures_defreturn') {\n      containerBlock.setFieldValue(this.hasStatements_, 'STATEMENTS');\n    } else {\n      containerBlock.removeInput('STATEMENT_INPUT');\n    }\n\n    return containerBlock;\n  },\n\n  /**\n   * Reconfigure this block based on the mutator dialog's components.\n   *\n   * @param containerBlock Root block in mutator.\n   * @this {Blockly.Block}\n   */\n  compose: function (containerBlock) {\n    // Note that only one of these four things can actually occur for any given\n    // composition, because the user can only drag blocks around so quickly.\n    // So we can use that when making assumptions inside the definitions of\n    // these sub procedures.\n    this.deleteParamsFromModel_(containerBlock);\n    this.renameParamsInModel_(containerBlock);\n    this.addParamsToModel_(containerBlock);\n\n    const hasStatements = containerBlock.getFieldValue('STATEMENTS');\n    if (hasStatements !== null) {\n      this.setStatements_(hasStatements === 'TRUE');\n    }\n  },\n\n  /**\n   * Deletes any parameters from the procedure model that do not have associated\n   * parameter blocks in the mutator.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  deleteParamsFromModel_: function (containerBlock) {\n    const ids = new Set(containerBlock.getDescendants().map((b) => b.id));\n    const model = this.getProcedureModel();\n    const count = model.getParameters().length;\n    for (let i = count - 1; i >= 0; i--) {\n      if (!ids.has(model.getParameter(i).getId())) {\n        model.deleteParameter(i);\n      }\n    }\n  },\n\n  /**\n   * Renames any parameters in the procedure model whose associated parameter\n   * blocks have been renamed.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  renameParamsInModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      const param = model.getParameter(i);\n      if (\n        param &&\n        param.getId() === paramBlock.id &&\n        param.getName() !== paramBlock.getFieldValue('NAME')\n      ) {\n        param.setName(paramBlock.getFieldValue('NAME'));\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n\n  /**\n   * Adds new parameters to the procedure model for any new procedure parameter\n   * blocks.\n   *\n   * @param containerBlock Root block in the mutator.\n   */\n  addParamsToModel_: function (containerBlock) {\n    const model = this.getProcedureModel();\n\n    let i = 0;\n    let paramBlock = containerBlock.getInputTargetBlock('STACK');\n    while (paramBlock && !paramBlock.isInsertionMarker()) {\n      if (\n        !model.getParameter(i) ||\n        model.getParameter(i).getId() !== paramBlock.id\n      ) {\n        model.insertParameter(\n          new ObservableParameterModel(\n            this.workspace,\n            paramBlock.getFieldValue('NAME'),\n            paramBlock.id,\n          ),\n          i,\n        );\n      }\n      paramBlock =\n        paramBlock.nextConnection && paramBlock.nextConnection.targetBlock();\n      i++;\n    }\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_def_mutator',\n  procedureDefMutator,\n  undefined,\n  ['procedures_mutatorarg'],\n);\n\nconst procedureDefContextMenuMixin = {\n  /**\n   * Add custom menu options to this block's context menu.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (\n    options: Array<\n      | Blockly.ContextMenuRegistry.ContextMenuOption\n      | Blockly.ContextMenuRegistry.LegacyContextMenuOption\n    >,\n  ) {\n    if (this.isInFlyout) {\n      return;\n    }\n\n    const xmlMutation = Blockly.utils.xml.createElement('mutation');\n    xmlMutation.setAttribute('name', this.getFieldValue('NAME'));\n    const params = this.getProcedureModel().getParameters();\n    for (const param of params) {\n      const xmlArg = Blockly.utils.xml.createElement('arg');\n      xmlArg.setAttribute('name', param.getName());\n      xmlMutation.appendChild(xmlArg);\n    }\n    const xmlBlock = Blockly.utils.xml.createElement('block');\n    xmlBlock.setAttribute('type', this.callType_);\n    xmlBlock.appendChild(xmlMutation);\n\n    // Add option to create caller.\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_CREATE_DO'].replace(\n        '%1',\n        this.getFieldValue('NAME'),\n      ),\n      callback: Blockly.ContextMenu.callbackFactory(\n        this,\n        xmlBlock,\n      ) as () => void,\n    });\n\n    // Add options to create getters for each parameter.\n    if (this.isCollapsed()) return;\n\n    for (const param of params) {\n      const argVar = param.getVariableModel();\n      const argXmlField = Blockly.Variables.generateVariableFieldDom(argVar);\n      const argXmlBlock = Blockly.utils.xml.createElement('block');\n      argXmlBlock.setAttribute('type', 'variables_get');\n      argXmlBlock.appendChild(argXmlField);\n      options.push({\n        enabled: true,\n        text: Blockly.Msg['VARIABLES_SET_CREATE_GET'].replace(\n          '%1',\n          argVar.name,\n        ),\n        callback: Blockly.ContextMenu.callbackFactory(\n          this,\n          argXmlBlock,\n        ) as () => void,\n      });\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_context_menu_mixin',\n  procedureDefContextMenuMixin,\n);\n\nconst procedureDefOnChangeMixin = {\n  onchange: function (e) {\n    if (e.type === Blockly.Events.BLOCK_CREATE && e.blockId === this.id) {\n      Blockly.Events.fire(\n        new ProcedureCreate(this.workspace, this.getProcedureModel()),\n      );\n    }\n    if (\n      e.type === Blockly.Events.BLOCK_CHANGE &&\n      e.blockId === this.id &&\n      e.element === 'disabled'\n    ) {\n      this.getProcedureModel().setEnabled(this.isEnabled());\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_def_onchange_mixin',\n  procedureDefOnChangeMixin,\n);\n\nconst procedureDefNoReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFNORETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defnoreturn_set_comment_helper',\n  procedureDefNoReturnSetCommentHelper,\n);\n\nconst procedureDefReturnSetCommentHelper = function () {\n  if (\n    (this.workspace.options.comments ||\n      (this.workspace.options.parentWorkspace &&\n        this.workspace.options.parentWorkspace.options.comments)) &&\n    Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']\n  ) {\n    this.setCommentText(Blockly.Msg['PROCEDURES_DEFRETURN_COMMENT']);\n  }\n};\nBlockly.Extensions.register(\n  'procedure_defreturn_set_comment_helper',\n  procedureDefReturnSetCommentHelper,\n);\n\nconst procedureDefNoReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defnoreturn_get_caller_block_mixin',\n  procedureDefNoReturnGetCallerBlockMixin,\n);\n\nconst procedureDefReturnGetCallerBlockMixin = {\n  callType_: 'procedures_callreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_defreturn_get_caller_block_mixin',\n  procedureDefReturnGetCallerBlockMixin,\n);\n\nconst procedureDefSetNoReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes(null);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_no_return_helper',\n  procedureDefSetNoReturnHelper,\n);\n\nconst procedureDefSetReturnHelper = function () {\n  this.getProcedureModel().setReturnTypes([]);\n};\nBlockly.Extensions.register(\n  'procedure_def_set_return_helper',\n  procedureDefSetReturnHelper,\n);\n\nconst procedureCallerGetDefMixin = function () {\n  const mixin = {\n    model_: null,\n\n    prevParams_: [],\n\n    argsMap_: new Map(),\n\n    /**\n     * Returns the procedure model associated with this block.\n     *\n     * @returns The procedure model associated with this block.\n     */\n    getProcedureModel() {\n      return this.model_;\n    },\n\n    /**\n     * Returns the procedure model tha was found.\n     *\n     * @param name The name of the procedure model to find.\n     * @param params The param names of the procedure model\n     *     to find.\n     * @returns The procedure model that was found.\n     */\n    findProcedureModel_(name, params = []) {\n      const workspace = this.getTargetWorkspace_();\n      const model = workspace\n        .getProcedureMap()\n        .getProcedures()\n        .find((proc) => proc.getName() === name);\n      if (!model) return null;\n\n      const returnTypes = model.getReturnTypes();\n      const hasMatchingReturn = this.hasReturn_ ? returnTypes : !returnTypes;\n      if (!hasMatchingReturn) return null;\n\n      const hasMatchingParams = model\n        .getParameters()\n        .every((p, i) => p.getName() === params[i]);\n      if (!hasMatchingParams) return null;\n\n      return model;\n    },\n\n    /**\n     * Returns the main workspace (i.e. not the flyout workspace) associated\n     * with this block.\n     *\n     * @returns The main workspace (i.e. not the flyout workspace) associated\n     *     with this block.\n     */\n    getTargetWorkspace_() {\n      return this.workspace.isFlyout\n        ? this.workspace.targetWorkspace\n        : this.workspace;\n    },\n\n    /**\n     * True if this is a procedure definition block, false otherwise (i.e.\n     * it is a caller).\n     *\n     * @returns False because this is not a procedure definition block.\n     */\n    isProcedureDef() {\n      return false;\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable names.\n     * @this {Blockly.Block}\n     */\n    getVars: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel().name);\n    },\n\n    /**\n     * Return all variables referenced by this block.\n     *\n     * @returns List of variable models.\n     * @this {Blockly.Block}\n     */\n    getVarModels: function () {\n      return this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getVariableModel());\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_get_def_mixin',\n  procedureCallerGetDefMixin,\n);\n\nconst procedureCallerVarMixin = function () {\n  const mixin = {\n    /**\n     * Notification that a variable is renaming but keeping the same ID.  If the\n     * variable is in use on this block, rerender to show the new name.\n     *\n     * @param variable The variable being renamed.\n     * @package\n     * @override\n     * @this {Blockly.Block}\n     */\n    updateVarName: function (variable) {\n      const containsVar = this.getProcedureModel()\n        .getParameters()\n        .some((p) => p.getVariableModel() === variable);\n      if (containsVar) {\n        this.doProcedureUpdate(); // Rerender.\n      }\n    },\n  };\n\n  this.mixin(mixin, true);\n};\n// Using register instead of registerMixin to avoid triggering warnings about\n// overriding built-ins.\nBlockly.Extensions.register(\n  'procedure_caller_var_mixin',\n  procedureCallerVarMixin,\n);\n\nconst procedureCallerMutator = {\n  paramsFromSerializedState_: [],\n\n  /**\n   * Create XML to represent the (non-editable) name and arguments.\n   * Backwards compatible serialization implementation.\n   *\n   * @returns XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function () {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const model = this.getProcedureModel();\n    if (!model) return container;\n\n    container.setAttribute('name', model.getName());\n    for (const param of model.getParameters()) {\n      const arg = Blockly.utils.xml.createElement('arg');\n      arg.setAttribute('name', param.getName());\n      container.appendChild(arg);\n    }\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the (non-editable) name and parameters.\n   * Backwards compatible serialization implementation.\n   *\n   * @param xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function (xmlElement) {\n    const name = xmlElement.getAttribute('name');\n    const params = [];\n    for (const n of xmlElement.childNodes) {\n      if (n.nodeName.toLowerCase() === 'arg') {\n        params.push(n.getAttribute('name'));\n      }\n    }\n    this.deserialize_(name, params);\n  },\n\n  /**\n   * Returns the state of this block as a JSON serializable object.\n   *\n   * @returns The state of\n   *     this block, ie the params and procedure name.\n   */\n  saveExtraState: function () {\n    const state = Object.create(null);\n    const model = this.getProcedureModel();\n    if (!model) {\n      // We reached here because we've deserialized a caller into a workspace\n      // where its model did not already exist (no procedures array in the json,\n      // and deserialized before any definition block), and are reserializing\n      // it before the event delay has elapsed and change listeners have run.\n      // (If they had run, we would have found or created a model).\n      // Just reserialize any deserialized state. Nothing should have happened\n      // in-between to change it.\n      state['name'] = this.getFieldValue('NAME');\n      state['params'] = this.paramsFromSerializedState_;\n      return state;\n    }\n    state['name'] = model.getName();\n    if (model.getParameters().length) {\n      state['params'] = model.getParameters().map((p) => p.getName());\n    }\n    return state;\n  },\n\n  /**\n   * Applies the given state to this block.\n   *\n   * @param state The state to apply to this block, ie the params and\n   *     procedure name.\n   */\n  loadExtraState: function (state) {\n    this.deserialize_(state['name'], state['params'] || []);\n  },\n\n  /**\n   * Applies the given name and params from the serialized state to the block.\n   *\n   * @param name The name to apply to the block.\n   * @param params The parameters to apply to the block.\n   */\n  deserialize_: function (name, params) {\n    this.setFieldValue(name, 'NAME');\n    if (!this.model_) this.model_ = this.findProcedureModel_(name, params);\n    if (this.getProcedureModel()) {\n      this.initBlockWithProcedureModel_();\n    } else {\n      // Create inputs based on the mutation so that children can be connected.\n      this.createArgInputs_(params);\n    }\n    this.paramsFromSerializedState_ = params;\n  },\n};\nBlockly.Extensions.registerMutator(\n  'procedure_caller_mutator',\n  procedureCallerMutator,\n);\n\nconst PROCEDURE_MODEL_DISABLED_REASON = 'PROCEDURE_MODEL_DISABLED';\n\nconst procedureCallerUpdateShapeMixin = {\n  /**\n   * Renders the block for the first time based on the procedure model.\n   */\n  initBlockWithProcedureModel_() {\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n    this.doProcedureUpdate();\n  },\n\n  /**\n   * Updates the shape of this block to reflect the state of the data model.\n   */\n  doProcedureUpdate: function () {\n    if (!this.getProcedureModel()) return;\n    const id = this.getProcedureModel().getId();\n    if (!this.getTargetWorkspace_().getProcedureMap().has(id)) {\n      this.dispose(true);\n      return;\n    }\n    this.updateName_();\n    this.updateEnabled_();\n    this.updateParameters_();\n  },\n\n  /**\n   * Updates the name field of this block to match the state of the data model.\n   */\n  updateName_: function () {\n    const name = this.getProcedureModel().getName();\n    this.setFieldValue(name, 'NAME');\n    const baseMsg = this.outputConnection\n      ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n      : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n    this.setTooltip(baseMsg.replace('%1', name));\n  },\n\n  /**\n   * Updates the enabled state of this block to match the state of the data\n   *     model.\n   */\n  updateEnabled_: function () {\n    this.setDisabledReason(\n      !this.getProcedureModel().getEnabled(),\n      PROCEDURE_MODEL_DISABLED_REASON,\n    );\n  },\n\n  /**\n   * Updates the parameter fields/inputs of this block to match the state of the\n   * data model.\n   */\n  updateParameters_: function () {\n    this.syncArgsMap_();\n    this.deleteAllArgInputs_();\n    this.addParametersLabel__();\n    this.createArgInputs_();\n    this.reattachBlocks_();\n    this.prevParams_ = [...this.getProcedureModel().getParameters()];\n  },\n\n  /**\n   * Makes sure that if we are updating the parameters before any move events\n   * have happened, the args map records the current state of the block. Does\n   * not remove entries from the array, since blocks can be disconnected\n   * temporarily during mutation (which triggers this method).\n   */\n  syncArgsMap_: function () {\n    // We look at the prevParams array because the current state of the block\n    // matches the old params, not the new params state.\n    for (const [i, p] of this.prevParams_.entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) this.argsMap_.set(p.getId(), target);\n    }\n  },\n\n  /**\n   * Saves a map of parameter IDs to target blocks attached to the inputs\n   * of this caller block.\n   */\n  updateArgsMap_: function () {\n    for (const [i, p] of this.getProcedureModel().getParameters().entries()) {\n      const target = this.getInputTargetBlock(`ARG${i}`);\n      if (target) {\n        this.argsMap_.set(p.getId(), target);\n      } else {\n        this.argsMap_.delete(p.getId());\n      }\n    }\n  },\n\n  /**\n   * Deletes all the parameter inputs on this block.\n   */\n  deleteAllArgInputs_: function () {\n    let i = 0;\n    while (this.getInput(`ARG${i}`)) {\n      this.removeInput(`ARG${i}`);\n      i++;\n    }\n  },\n\n  /**\n   * Adds or removes the parameter label to match the state of the data model.\n   */\n  addParametersLabel__: function () {\n    const topRow = this.getInput('TOPROW');\n    if (this.getProcedureModel().getParameters().length) {\n      if (!this.getField('WITH')) {\n        topRow.appendField(\n          Blockly.Msg['PROCEDURES_CALL_BEFORE_PARAMS'],\n          'WITH',\n        );\n        topRow.init();\n      }\n    } else if (this.getField('WITH')) {\n      topRow.removeField('WITH');\n    }\n  },\n\n  /**\n   * Creates all of the parameter inputs to match the state of the data model.\n   *\n   * @param params The params to add to the block, or null to\n   *     use the params defined in the procedure model.\n   */\n  createArgInputs_: function (params = null) {\n    if (!params) {\n      params = this.getProcedureModel()\n        .getParameters()\n        .map((p) => p.getName());\n    }\n    for (const [i, p] of params.entries()) {\n      this.appendValueInput(`ARG${i}`)\n        .appendField(new Blockly.FieldLabel(p), `ARGNAME${i}`)\n        .setAlign(Blockly.inputs.Align.RIGHT);\n    }\n  },\n\n  /**\n   * Reattaches blocks to this blocks' inputs based on the data saved in the\n   * argsMap_.\n   */\n  reattachBlocks_: function () {\n    const params = this.getProcedureModel().getParameters();\n    for (const [i, p] of params.entries()) {\n      if (!this.argsMap_.has(p.getId())) continue;\n      this.getInput(`ARG${i}`).connection.connect(\n        this.argsMap_.get(p.getId()).outputConnection,\n      );\n    }\n  },\n\n  /**\n   * Notification that a procedure is renaming.\n   * If the name matches this block's procedure, rename it.\n   *\n   * @param oldName Previous name of procedure.\n   * @param newName Renamed procedure.\n   * @this {Blockly.Block}\n   */\n  renameProcedure: function (oldName, newName) {\n    if (Blockly.Names.equals(oldName, this.getFieldValue('NAME'))) {\n      this.setFieldValue(newName, 'NAME');\n      const baseMsg = this.outputConnection\n        ? Blockly.Msg['PROCEDURES_CALLRETURN_TOOLTIP']\n        : Blockly.Msg['PROCEDURES_CALLNORETURN_TOOLTIP'];\n      this.setTooltip(baseMsg.replace('%1', newName));\n    }\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_update_shape_mixin',\n  procedureCallerUpdateShapeMixin,\n);\n\nconst procedureCallerOnChangeMixin = {\n  /**\n   * Procedure calls cannot exist without the corresponding procedure\n   * definition.  Enforce this link whenever an event is fired.\n   *\n   * @param event Change event.\n   * @this {Blockly.Block}\n   */\n  onchange: function (event) {\n    if (this.disposed || this.workspace.isFlyout) return;\n    if (event.type === Blockly.Events.BLOCK_MOVE) this.updateArgsMap_(true);\n    if (\n      event.type !== Blockly.Events.FINISHED_LOADING &&\n      !this.eventIsCreatingThisBlockDuringPaste_(event)\n    )\n      return;\n\n    // We already found our model, which means we don't need to create a block.\n    if (this.getProcedureModel()) return;\n\n    // Look for the case where a procedure call was created (usually through\n    // paste) and there is no matching definition.  In this case, create\n    // an empty definition block with the correct signature.\n    const name = this.getFieldValue('NAME');\n    let def = Blockly.Procedures.getDefinition(name, this.workspace);\n    if (!this.defMatches_(def)) def = null;\n    if (!def) {\n      // We have no def nor procedure model.\n      Blockly.Events.setGroup(event.group);\n      this.model_ = this.createDef_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n      Blockly.Events.setGroup(false);\n    }\n    if (!this.getProcedureModel()) {\n      // We have a def, but no reference to its model.\n      this.model_ = this.findProcedureModel_(\n        this.getFieldValue('NAME'),\n        this.paramsFromSerializedState_,\n      );\n    }\n    this.initBlockWithProcedureModel_();\n  },\n\n  /**\n   * @param event The event to check.\n   * @returns True if the given event is a paste event for this block.\n   */\n  eventIsCreatingThisBlockDuringPaste_(event) {\n    return (\n      event.type === Blockly.Events.BLOCK_CREATE &&\n      (event.blockId === this.id || event.ids.indexOf(this.id) !== -1) &&\n      // Record undo makes sure this is during paste.\n      event.recordUndo\n    );\n  },\n\n  /**\n   * Returns true if the given def block matches the definition of this caller\n   * block.\n   *\n   * @param defBlock The definition block to check against.\n   * @returns Whether the def block matches or not.\n   */\n  defMatches_(defBlock) {\n    return (\n      defBlock &&\n      defBlock.type === this.defType_ &&\n      JSON.stringify(defBlock.getVars()) ===\n        JSON.stringify(this.paramsFromSerializedState_)\n    );\n  },\n\n  /**\n   * Creates a procedure definition block with the given name and params,\n   * and returns the procedure model associated with it.\n   *\n   * @param name The name of the procedure to create.\n   * @param params The names of the parameters to create.\n   * @returns The procedure model associated with the new\n   *     procedure definition block.\n   */\n  createDef_(name, params = []) {\n    const xy = this.getRelativeToSurfaceXY();\n    const newName = Blockly.Procedures.findLegalName(name, this);\n    this.renameProcedure(name, newName);\n\n    const blockDef = {\n      type: this.defType_,\n      x: xy.x + Blockly.config.snapRadius * (this.RTL ? -1 : 1),\n      y: xy.y + Blockly.config.snapRadius * 2,\n      extraState: {\n        params: params.map((p) => ({name: p})),\n      },\n      fields: {NAME: newName},\n    };\n    const block = Blockly.serialization.blocks.append(\n      blockDef,\n      this.getTargetWorkspace_(),\n      {recordUndo: true},\n    );\n    return (block as unknown as IProcedureBlock).getProcedureModel();\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_onchange_mixin',\n  procedureCallerOnChangeMixin,\n);\n\nconst procedureCallerContextMenuMixin = {\n  /**\n   * Add menu option to find the definition block for this call.\n   *\n   * @param options List of menu options to add to.\n   * @this {Blockly.Block}\n   */\n  customContextMenu: function (options) {\n    if (!this.workspace.isMovable()) {\n      // If we center on the block and the workspace isn't movable we could\n      // lose blocks at the edges of the workspace.\n      return;\n    }\n\n    const name = this.getFieldValue('NAME');\n    const workspace = this.workspace;\n    const callback = function () {\n      const def = Blockly.Procedures.getDefinition(name, workspace);\n      if (def && def instanceof Blockly.BlockSvg) {\n        workspace.centerOnBlock(def.id);\n        def.select();\n      }\n    };\n    options.push({\n      enabled: true,\n      text: Blockly.Msg['PROCEDURES_HIGHLIGHT_DEF'],\n      callback: callback,\n    });\n  },\n};\nBlockly.Extensions.registerMixin(\n  'procedure_caller_context_menu_mixin',\n  procedureCallerContextMenuMixin,\n);\n\nconst procedureCallerNoReturnGetDefBlockMixin = {\n  hasReturn_: false,\n  defType_: 'procedures_defnoreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callernoreturn_get_def_block_mixin',\n  procedureCallerNoReturnGetDefBlockMixin,\n);\n\nconst procedureCallerReturnGetDefBlockMixin = {\n  hasReturn_: true,\n  defType_: 'procedures_defreturn',\n};\nBlockly.Extensions.registerMixin(\n  'procedure_callerreturn_get_def_block_mixin',\n  procedureCallerReturnGetDefBlockMixin,\n);\n","/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/** The interface for a block which models a procedure. */\nexport interface IProcedureBlock {\n  getProcedureModel(): Blockly.procedures.IProcedureModel;\n  doProcedureUpdate(): void;\n  isProcedureDef(): boolean;\n}\n\n/**\n * A type guard which checks if the given block is a procedure block.\n *\n * @param block The block to check for procedure-y-ness.\n * @returns Whether this block is a procedure block or not.\n */\nexport function isProcedureBlock(\n  block: Blockly.Block | IProcedureBlock,\n): block is IProcedureBlock {\n  return (\n    (block as IProcedureBlock).getProcedureModel !== undefined &&\n    (block as IProcedureBlock).doProcedureUpdate !== undefined &&\n    (block as IProcedureBlock).isProcedureDef !== undefined\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ObservableParameterModel} from './observable_parameter_model';\nimport {ObservableProcedureModel} from './observable_procedure_model';\n\nexport {blocks} from './blocks';\nexport {IProcedureBlock, isProcedureBlock} from './i_procedure_block';\nexport {ProcedureBase, ProcedureBaseJson} from './events_procedure_base';\nexport {\n  ProcedureChangeReturn,\n  ProcedureChangeReturnJson,\n} from './events_procedure_change_return';\nexport {ProcedureCreate, ProcedureCreateJson} from './events_procedure_create';\nexport {ProcedureDelete, ProcedureDeleteJson} from './events_procedure_delete';\nexport {\n  ProcedureParameterBase,\n  ProcedureParameterBaseJson,\n} from './events_procedure_parameter_base';\nexport {\n  ProcedureParameterCreate,\n  ProcedureParameterCreateJson,\n} from './events_procedure_parameter_create';\nexport {\n  ProcedureParameterDelete,\n  ProcedureParameterDeleteJson,\n} from './events_procedure_parameter_delete';\nexport {\n  ProcedureParameterRename,\n  ProcedureParameterRenameJson,\n} from './events_procedure_parameter_rename';\nexport {ProcedureRename, ProcedureRenameJson} from './events_procedure_rename';\nexport {triggerProceduresUpdate} from './update_procedures';\n\nexport {ObservableParameterModel, ObservableProcedureModel};\n\n/**\n * Unregisters all of the procedure blocks.\n *\n * Usually used to unregister the built-in blocks, before register the\n * blocks provided by this plugin.\n */\nexport function unregisterProcedureBlocks() {\n  delete Blockly.Blocks['procedures_defnoreturn'];\n  delete Blockly.Blocks['procedures_callnoreturn'];\n  delete Blockly.Blocks['procedures_defreturn'];\n  delete Blockly.Blocks['procedures_callreturn'];\n}\n\n/**\n * Unregisters any existing procedure serializer, and registers a new one\n * parameterized with the shareable procedure backing data models.\n */\nexport function registerProcedureSerializer() {\n  Blockly.serialization.registry.unregister('procedures');\n  Blockly.serialization.registry.register(\n    'procedures',\n    new Blockly.serialization.procedures.ProcedureSerializer(\n      ObservableProcedureModel,\n      ObservableParameterModel,\n    ),\n  );\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ProcedureBase","Abstract","constructor","workspace","procedure","super","type","TYPE","isBlank","workspaceId","id","toJson","json","getId","ProcedureParameterBase","parameter","recordUndo","findMatchingParameter","procedureId","paramId","getProcedureMap","getParameters","find","p","ProcedureParameterRename","oldName","newName","newVarId","getName","getVariableModel","run","forward","getEventWorkspace_","setName","fromJson","Error","triggerProceduresUpdate","isClearing","block","getAllBlocks","isProcedureBlock","doProcedureUpdate","register","Type","EVENT","ObservableParameterModel","name","varId","shouldFireEvents","procedureModel","idGenerator","genUid","variable","createBackingVariable","getVariable","createVariable","fire","setTypes","types","getTypes","startPublishing","stopPublishing","setProcedureModel","model","saveState","state","length","loadState","ProcedureChangeReturn","workpace","oldTypes","newTypes","getReturnTypes","setReturnTypes","ProcedureCreate","procedureMap","add","delete","procedures","saveProcedure","loadProcedure","ObservableProcedureModel","ProcedureDelete","ProcedureEnable","newState","oldState","getEnabled","setEnabled","ProcedureParameterCreate","index","insertParameter","deleteParameter","ProcedureParameterDelete","ProcedureRename","parameters","returnTypes","enabled","shouldTriggerUpdates","parameterModel","splice","oldParam","oldReturnTypes","startBulkUpdate","endBulkUpdate","getParameter","param","blocks","createBlockDefinitionsFromJsonArray","message0","message1","args0","text","spellcheck","args1","style","helpUrl","tooltip","extensions","mutator","nextStatement","previousStatement","message2","args2","align","output","mixin","model_","getProcedureModel","isProcedureDef","getVars","map","getVarModels","destroy","isInsertionMarker","findLegalName","getFieldValue","disable","enable","renameVarById","oldId","newId","oldVar","getVariableById","findIndex","newVar","updateVarName","some","procedureDefUpdateShapeMixin","setFieldValue","updateParameters_","updateMutator_","params","paramString","join","getIcon","MutatorIcon","bubbleIsVisible","mutatorWorkspace","getWorkspace","getBlockById","setStatements_","hasStatements","hasStatements_","appendStatementInput","appendField","getInput","moveInputBefore","statementConnection_","stackConnection","connection","targetConnection","stackBlock","targetBlock","unplug","bumpNeighbours","removeInput","registerMixin","nameField","getField","setValue","setValidator","rename","procedureDefMutator","mutationToDom","container","xml","createElement","varModel","setAttribute","appendChild","domToMutation","xmlElement","childNodes","node","nodeName","toLowerCase","getAttribute","saveExtraState","doFullSerialization","create","loadExtraState","has","newParams","newIds","Set","currParams","decompose","containerBlockDef","inputs","STACK","connDef","fields","NAME","next","containerBlock","append","compose","deleteParamsFromModel_","renameParamsInModel_","addParamsToModel_","ids","getDescendants","b","paramBlock","getInputTargetBlock","nextConnection","registerMutator","procedureDefContextMenuMixin","customContextMenu","options","isInFlyout","xmlMutation","xmlArg","xmlBlock","callType_","push","replace","callback","callbackFactory","isCollapsed","argVar","argXmlField","generateVariableFieldDom","argXmlBlock","procedureDefOnChangeMixin","onchange","e","BLOCK_CREATE","blockId","BLOCK_CHANGE","element","isEnabled","comments","parentWorkspace","setCommentText","prevParams_","argsMap_","Map","findProcedureModel_","getTargetWorkspace_","getProcedures","proc","hasReturn_","every","isFlyout","targetWorkspace","procedureCallerMutator","paramsFromSerializedState_","arg","n","deserialize_","initBlockWithProcedureModel_","createArgInputs_","procedureCallerUpdateShapeMixin","updateName_","updateEnabled_","dispose","baseMsg","outputConnection","setTooltip","setDisabledReason","syncArgsMap_","deleteAllArgInputs_","addParametersLabel__","reattachBlocks_","entries","target","set","updateArgsMap_","topRow","init","removeField","appendValueInput","setAlign","Align","RIGHT","connect","renameProcedure","equals","procedureCallerOnChangeMixin","event","disposed","BLOCK_MOVE","FINISHED_LOADING","eventIsCreatingThisBlockDuringPaste_","def","getDefinition","defMatches_","setGroup","group","createDef_","indexOf","defBlock","defType_","JSON","stringify","xy","getRelativeToSurfaceXY","blockDef","x","snapRadius","RTL","y","extraState","procedureCallerContextMenuMixin","isMovable","centerOnBlock","select","unregisterProcedureBlocks","registerProcedureSerializer","registry","unregister","ProcedureSerializer"],"sourceRoot":""}